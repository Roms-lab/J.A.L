export module J.A.L_Converter;

import <iostream>;
import <cstdlib>;
import <fstream>;
import <string>;
import <vector>;
import <sstream>;
import <stdexcept>;

// -------------------------------------------------
// J.A.L CONVERTER
// -------------------------------------------------

export inline std::string Filepath;

export inline void ConvertJAL() {
    std::cout << "Enter File Path: ";
    std::cin >> Filepath;
    std::cout << "\nCompiling .JALC file at " << Filepath << "\n";

    // Input file stream for reading the .JALC file
    std::ifstream inputFile(Filepath);
    if (!inputFile.is_open()) {
        std::cerr << "Error: Could not open the specified file." << std::endl;
        return;
    }

    // Output file stream for writing the converted .c file
    std::ofstream outputFile("Output.c");
    if (!outputFile.is_open()) {
        std::cerr << "Error: Could not create output file 'Output.c'." << std::endl;
        return;
    }

    bool usesPrintf = false;
    bool usesWait = false;
    bool usesPing = false;
    bool usesOpen = false;
    std::vector<std::string> lines;
    std::string line;

    while (std::getline(inputFile, line)) {
        lines.push_back(line);
    }
    inputFile.close();

    std::stringstream body;
    for (const auto& l : lines) {
        std::string trimmed_line = l;
        size_t first = trimmed_line.find_first_not_of(" \t");
        if (std::string::npos != first) {
            trimmed_line = trimmed_line.substr(first);
        }

        if (trimmed_line.rfind("display", 0) == 0) {
            usesPrintf = true;
            std::string content = trimmed_line.substr(std::string("display").length());
            size_t start = content.find_first_not_of(" \t");
            if (std::string::npos != start) {
                content = content.substr(start);
            }

            // Generate printf, allowing for content with or without quotes
            // Note: C-style format specifier "%s" is used for strings
            // and the output is escaped to handle special characters correctly.
            body << "    printf(\"%s\\n\", \"" << content << "\");\n";
        }
        else if (trimmed_line.rfind("wait", 0) == 0) {
            usesWait = true;
            std::string number_str = trimmed_line.substr(std::string("wait").length());
            try {
                int seconds = std::stoi(number_str);
                body << "    jal_sleep(" << seconds << ");\n";
            }
            catch (const std::invalid_argument& e) {
                body << "    // Error: Invalid number for 'wait' command: " << number_str << "\n";
            }
        }
        else if (trimmed_line.rfind("ping", 0) == 0) {
            usesPing = true;
            std::string target = trimmed_line.substr(std::string("ping").length());
            size_t start = target.find_first_not_of(" \t");
            if (std::string::npos != start) {
                target = target.substr(start);
            }
            body << "    printf(\"Pinging %s...\\n\", \"" << target << "\");\n";
            body << "    jal_ping(\"" << target << "\");\n";
        }
        else if (trimmed_line.rfind("open", 0) == 0) {
            usesOpen = true;
            std::string file_path = trimmed_line.substr(std::string("open").length());
            size_t start = file_path.find_first_not_of(" \t");
            if (std::string::npos != start) {
                file_path = file_path.substr(start);
            }
            body << "    printf(\"Opening file: %s...\\n\", \"" << file_path << "\");\n";
            body << "    jal_open(\"" << file_path << "\");\n";
        }
        else {
            body << "    // Original JAL line: " << l << "\n";
        }
    }

    outputFile << "// Generated By J.A.L Converter.\n";
    outputFile << "\n";
    outputFile << "#include <iostream>\n";
    outputFile << "#include <cstdlib>\n";
    outputFile << "#include <string>\n";
    outputFile << "#include <stdexcept>\n";

    if (usesPrintf) {
        outputFile << "#include <cstdio>\n";
    }

    if (usesWait) {
        outputFile << "#if defined(_WIN32) || defined(_WIN64)\n";
        outputFile << "#include <windows.h>\n";
        outputFile << "#else\n";
        outputFile << "#include <unistd.h>\n";
        outputFile << "#endif\n";
        outputFile << "\n";
        outputFile << "// Cross-platform sleep function\n";
        outputFile << "void jal_sleep(unsigned int seconds) {\n";
        outputFile << "#if defined(_WIN32) || defined(_WIN64)\n";
        outputFile << "    Sleep(seconds * 1000); // Windows Sleep takes milliseconds\n";
        outputFile << "#else\n";
        outputFile << "    sleep(seconds); // POSIX sleep takes seconds\n";
        outputFile << "#endif\n";
        outputFile << "}\n";
        outputFile << "\n";
    }

    if (usesPing) {
        outputFile << "// Cross-platform ping function using system calls\n";
        outputFile << "void jal_ping(const std::string& target) {\n";
        outputFile << "    std::string command;\n";
        outputFile << "#if defined(_WIN32) || defined(_WIN64)\n";
        outputFile << "    command = \"ping -n 1 \" + target;\n";
        outputFile << "#else\n";
        outputFile << "    command = \"ping -c 1 \" + target;\n";
        outputFile << "#ifdef __APPLE__\n";
        outputFile << "    command = \"ping -c 1 \" + target;\n";
        outputFile << "#endif\n";
        outputFile << "#endif\n";
        outputFile << "    std::system(command.c_str());\n";
        outputFile << "}\n";
        outputFile << "\n";
    }

    if (usesOpen) {
        outputFile << "// Cross-platform open function using system calls\n";
        outputFile << "void jal_open(const std::string& file_path) {\n";
        outputFile << "    std::string command;\n";
        outputFile << "#if defined(_WIN32) || defined(_WIN64)\n";
        outputFile << "    command = \"start \" + file_path;\n";
        outputFile << "#else\n";
        outputFile << "    command = \"xdg-open \" + file_path;\n";
        outputFile << "#ifdef __APPLE__\n";
        outputFile << "    command = \"open \" + file_path;\n";
        outputFile << "#endif\n";
        outputFile << "#endif\n";
        outputFile << "    std::system(command.c_str());\n";
        outputFile << "}\n";
        outputFile << "\n";
    }

    outputFile << "int main() {\n";
    outputFile << body.str();
    outputFile << "\n";
    outputFile << "    return 0;\n";
    outputFile << "}\n";

    outputFile.close();
    std::cout << "Conversion complete. Check 'Output.c' for the result." << std::endl;
}

